`line 2 "calc.tlv" 0 //_\TLV_version 1d: tl-x.org, generated by SandPiper(TM) 1.9-2018/02/11-beta
`include "sp_default.vh" //_\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   // Included URL: "https://raw.githubusercontent.com/stevehoover/RISC-V_MYTH_Workshop/9c5b893e6e8b317e9c9b1c0158d2cd07c65f1378/tlv_lib/calculator_shell_lib.tlv"

//_\SV
   module top(input logic clk, input logic reset, input logic [31:0] cyc_cnt, output logic passed, output logic failed);    /* verilator lint_save */ /* verilator lint_off UNOPTFLAT */  bit [256:0] RW_rand_raw; bit [256+63:0] RW_rand_vect; pseudo_rand #(.WIDTH(257)) pseudo_rand (clk, reset, RW_rand_raw[256:0]); assign RW_rand_vect[256+63:0] = {RW_rand_raw[62:0], RW_rand_raw};  /* verilator lint_restore */  /* verilator lint_off WIDTH */ /* verilator lint_off UNOPTFLAT */   // (Expanded in Nav-TLV pane.)

`include "calc_gen.sv" //_\TLV
   //_|calc
      //_@1
         assign CALC_reset_a1 = reset;
         
         
         // YOUR CODE HERE
         assign CALC_val1_a1[31:0] = CALC_output_a3;
         assign CALC_val2_a1[31:0] = CALC_rand_a1[3:0];
         //counter
         assign CALC_counter_a1 = CALC_reset_a1?0:(CALC_counter_a2+1);
         assign CALC_valid_a1 = CALC_reset_a1 || CALC_counter_a1;
      //_?$valid
         //_@1
            assign CALC_sum_a1[31:0] = CALC_val1_a1[31:0] + CALC_val2_a1[31:0];
            assign CALC_diff_a1[31:0] = CALC_val1_a1[31:0] - CALC_val2_a1[31:0];
            assign CALC_mult_a1[31:0] = CALC_val1_a1[31:0] * CALC_val2_a1[31:0];
            assign CALC_quot_a1[31:0] = CALC_val1_a1[31:0] / CALC_val2_a1[31:0];
            
         //_@2
            assign CALC_mem_a2[31:0] = 
               CALC_reset_a2 ? 0:
               (CALC_op_a2[2:0]==3'b101)
                  ? CALC_mem_a4[31:0] : CALC_output_a4;
               
            
            assign CALC_output_a2[31:0] = 
               CALC_reset_a2 ? 0:
               (CALC_op_a2[2:0]==3'b000)
                  ? CALC_sum_a2[31:0] :
               (CALC_op_a2[2:0]==3'b001)
                  ? CALC_diff_a2[31:0] :
               (CALC_op_a2[2:0]==3'b010)
                  ? CALC_mult_a2[31:0] :
               (CALC_op_a2[2:0]==3'b011)
                  ? CALC_quot_a2[31:0] :
               (CALC_op_a2[2:0]==3'b100)
                  ? CALC_mem_a4[31:0] : CALC_val1_a2[31:0];
                  
            

      // Macro instantiations for calculator visualization(disabled by default).
      // Uncomment to enable visualisation, and also,
      // NOTE: If visualization is enabled, $op must be defined to the proper width using the expression below.
      //       (Any signals other than $rand1, $rand2 that are not explicitly assigned will result in strange errors.)
      //       You can, however, safely use these specific random signals as described in the videos:
      //  o $rand1[3:0]
      //  o $rand2[3:0]
      //  o $op[x:0]
      
   //m4+cal_viz(@3) // Arg: Pipeline stage represented by viz, should be atleast equal to last stage of CALCULATOR logic.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   assign passed = cyc_cnt > 40;
   assign failed = 1'b0; endgenerate
   

//_\SV
   endmodule

