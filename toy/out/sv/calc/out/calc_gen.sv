// Generated by SandPiper(TM) 1.9-2018/02/11-beta from Redwood EDA.
// Redwood EDA does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


`include "sandpiper_gen.vh"





//
// Signals declared top-level.
//

// For |calc$counter.
logic CALC_counter_a1,
      CALC_counter_a2;

// For |calc$diff.
logic [31:0] CALC_diff_a1,
             CALC_diff_a2;

// For |calc$mem.
logic [31:0] CALC_mem_a2,
             CALC_mem_a3,
             CALC_mem_a4;

// For |calc$mult.
logic [31:0] CALC_mult_a1,
             CALC_mult_a2;

// For |calc$op.
logic [2:0] CALC_op_a2;

// For |calc$output.
logic [31:0] CALC_output_a2,
             CALC_output_a3,
             CALC_output_a4;

// For |calc$quot.
logic [31:0] CALC_quot_a1,
             CALC_quot_a2;

// For |calc$rand.
logic [3:0] CALC_rand_a1;

// For |calc$reset.
logic CALC_reset_a1,
      CALC_reset_a2;

// For |calc$sum.
logic [31:0] CALC_sum_a1,
             CALC_sum_a2;

// For |calc$val1.
logic [31:0] CALC_val1_a1,
             CALC_val1_a2;

// For |calc$val2.
logic [31:0] CALC_val2_a1;

// For |calc$valid.
logic CALC_valid_a1,
      CALC_valid_a2,
      CALC_valid_a3;


//
// Scope: |calc
//

// Clock signals.
logic clkP_CALC_valid_a2 ;
logic clkP_CALC_valid_a3 ;
logic clkP_CALC_valid_a4 ;


generate


   //
   // Scope: |calc
   //

      // For $counter.
      always_ff @(posedge clk) CALC_counter_a2 <= CALC_counter_a1;

      // For $diff.
      always_ff @(posedge clkP_CALC_valid_a2) CALC_diff_a2[31:0] <= CALC_diff_a1[31:0];

      // For $mem.
      always_ff @(posedge clkP_CALC_valid_a3) CALC_mem_a3[31:0] <= CALC_mem_a2[31:0];
      always_ff @(posedge clkP_CALC_valid_a4) CALC_mem_a4[31:0] <= CALC_mem_a3[31:0];

      // For $mult.
      always_ff @(posedge clkP_CALC_valid_a2) CALC_mult_a2[31:0] <= CALC_mult_a1[31:0];

      // For signal $op, which had no assignment.
      assign CALC_op_a2[2:0] = 'x;

      // For $output.
      always_ff @(posedge clkP_CALC_valid_a3) CALC_output_a3[31:0] <= CALC_output_a2[31:0];
      always_ff @(posedge clkP_CALC_valid_a4) CALC_output_a4[31:0] <= CALC_output_a3[31:0];

      // For $quot.
      always_ff @(posedge clkP_CALC_valid_a2) CALC_quot_a2[31:0] <= CALC_quot_a1[31:0];

      // For signal $rand, which had no assignment.
      assign CALC_rand_a1[3:0] = 'x;

      // For $reset.
      always_ff @(posedge clk) CALC_reset_a2 <= CALC_reset_a1;

      // For $sum.
      always_ff @(posedge clkP_CALC_valid_a2) CALC_sum_a2[31:0] <= CALC_sum_a1[31:0];

      // For $val1.
      always_ff @(posedge clk) CALC_val1_a2[31:0] <= CALC_val1_a1[31:0];

      // For $valid.
      always_ff @(posedge clk) CALC_valid_a2 <= CALC_valid_a1;
      always_ff @(posedge clk) CALC_valid_a3 <= CALC_valid_a2;




endgenerate



//
// Gated clocks.
//

generate



   //
   // Scope: |calc
   //

      clk_gate gen_clkP_CALC_valid_a2(clkP_CALC_valid_a2, clk, 1'b1, CALC_valid_a1, 1'b0);
      clk_gate gen_clkP_CALC_valid_a3(clkP_CALC_valid_a3, clk, 1'b1, CALC_valid_a2, 1'b0);
      clk_gate gen_clkP_CALC_valid_a4(clkP_CALC_valid_a4, clk, 1'b1, CALC_valid_a3, 1'b0);



endgenerate



generate   // This is awkward, but we need to go into 'generate' context in the line that `includes the declarations file.
